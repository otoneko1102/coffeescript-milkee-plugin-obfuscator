// Generated by CoffeeScript 2.7.0
var PREFIX, c, consola, fs, i, len, main, method, obfuscator, path, pkg, ref;

fs = require('fs');

path = require('path');

consola = require('consola');

obfuscator = require('javascript-obfuscator');

pkg = require('../package.json');

PREFIX = `[${pkg.name}]`;

// Create a custom logger with prefix
c = {};

ref = ['log', 'info', 'success', 'warn', 'error', 'debug', 'start', 'box'];
for (i = 0, len = ref.length; i < len; i++) {
  method = ref[i];
  (function(method) {
    return c[method] = function(...args) {
      if (typeof args[0] === 'string') {
        args[0] = `${PREFIX} ${args[0]}`;
      }
      return consola[method](...args);
    };
  })(method);
}

// Main plugin function
main = function(compilationResult, opts = {}) {
  var code, compiledFiles, config, configOpts, error, file, j, len1, map, mapName, mapPath, merged, obfuscated, optsForFile, ref1, result, results, stderr, stdout, url;
  ({config, compiledFiles, stdout, stderr} = compilationResult);
  configOpts = (config != null ? (ref1 = config.milkee) != null ? ref1.obfuscatorOptions : void 0 : void 0) || {};
  merged = Object.assign({}, configOpts, opts);
  c.info(`Obfuscates ${compiledFiles.length} file(s)`);
  try {
    results = [];
    for (j = 0, len1 = compiledFiles.length; j < len1; j++) {
      file = compiledFiles[j];
      if (!(file != null ? file.endsWith('.js') : void 0)) {
        continue;
      }
      if (Array.isArray(merged.exclude) && merged.exclude.some(function(p) {
        return file.indexOf(p) !== -1 || path.basename(file) === p;
      })) {
        c.info(`Skipped (excluded): ${file}`);
        continue;
      }
      optsForFile = Object.assign({}, merged);
      if (optsForFile.inputFileName == null) {
        optsForFile.inputFileName = path.basename(file);
      }
      if (optsForFile.vmObfuscation) {
        c.error("vmObfuscation requires JavaScript Obfuscator Pro (use obfuscatePro with an API token).");
        throw new Error('vmObfuscation requires JavaScript Obfuscator Pro (obfuscatePro)');
      }
      code = fs.readFileSync(file, 'utf8');
      result = obfuscator.obfuscate(code, optsForFile);
      obfuscated = result.getObfuscatedCode();
      if (optsForFile.sourceMap && optsForFile.sourceMapMode !== 'inline') {
        map = result.getSourceMap();
        if (map && map.length > 0) {
          mapName = optsForFile.sourceMapFileName ? optsForFile.sourceMapFileName : path.basename(file) + '.map';
          mapPath = path.join(path.dirname(file), mapName);
          fs.writeFileSync(mapPath, map, 'utf8');
          url = optsForFile.sourceMapBaseUrl ? optsForFile.sourceMapBaseUrl.replace(/\/$/, '') + '/' + mapName : mapName;
          obfuscated += `\n//# sourceMappingURL=${url}`;
        }
      }
      fs.writeFileSync(file, obfuscated, 'utf8');
      results.push(c.success(`Obfuscated: ${file}`));
    }
    return results;
  } catch (error1) {
    error = error1;
    c.error(`Obfuscation failed: ${error.message}`);
    throw error;
  }
};

module.exports = function(userOptions = {}) {
  return function(compilationResult) {
    var mergedOpts, ref1, ref2;
    mergedOpts = Object.assign({}, (compilationResult != null ? (ref1 = compilationResult.config) != null ? (ref2 = ref1.milkee) != null ? ref2.obfuscatorOptions : void 0 : void 0 : void 0) || {}, userOptions);
    return main(compilationResult, mergedOpts);
  };
};
